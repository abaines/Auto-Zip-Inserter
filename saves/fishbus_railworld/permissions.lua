--[[
Copyright 2017-2018 "Kovus" <kovus@soulless.wtf>

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	

	permissions.lua

	Responsible for managing a permissions systems for users.  In combination
	with permission_definition.lua (which should be able to be generated by
	this script), this script manages permissions for various groups of
	users.

	Group permissions can be inclusive of other groups, so that a heirarchical
	(and recursive inclusion) design may be established.  If a group has no
	permissions defined, then that group will have no permissions at all.

	Custom permissions may be defined if the permission name starts with
	"custom." such as "custom.adminPanel".  Lookups may be done against these
	custom permissions.
--]]

require 'lib/event_extend'
require 'lib/fb_util' -- for arr_contains & player lookup

local default_perm_def = require "permission_definition"
local default_user_def = require "permission_users"

perms = {} -- module.

local function mod_init()
	if not global.perm_definition then
		log("Loading perms from file")
		global.perm_definition = default_perm_def
	end
	if not global.user_definition then
		log("Loading user data from file")
		global.user_definition = default_user_def
	end

	if not global.perm_definition.customPerms then
		global.perm_definition.customPerms = {}
	end
end

-- Creates a group in Factorio's permissions system with no permissions
local function createGroup(groupName)
	local fpermgroup = nil
	if game.permissions.groups then
		fpermgroup = game.permissions.get_group(groupName)
	end

	-- If passed an existing group, wipe out the permissions anyway.
	if not fpermgroup then
		fpermgroup = game.permissions.create_group(groupName)
	end
	for act_name, act_number in pairs(defines.input_action) do
		fpermgroup.set_allows_action(defines.input_action[act_name], false)
	end
	global.perm_definition.groups[groupName].ancestors = {}
	global.perm_definition.groups[groupName].users = {}
	global.perm_definition.groups[groupName].name = groupName
end

-- Sets up Factorio's permissions group with the permissions provided
local function setGroupPermissions(groupName, perms)
	if not perms or (type(perms) == 'table' and table_size(perms) == 0) then
		-- no perms?  nothing to do.
		return
	end
	local permgroup = game.permissions.get_group(groupName)
	if not permgroup then
		game.print({'permissions.set_perms_nonexistent', groupName})
		return
	end

	for _, perm_name in pairs(perms) do
		local fperm = defines.input_action[perm_name]
		if fperm then
			permgroup.set_allows_action(fperm, true)
		end
	end
end

-- Add permissions from a group source, including inherited perms.
local function setGroupPermissionsFrom(target_name, group_source)
	setGroupPermissions(target_name, group_source.permissions)
	if group_source.inherit_perms_from and #group_source.inherit_perms_from > 0 then
		for _, subgroup in pairs(group_source.inherit_perms_from) do
			local sg_def = global.perm_definition.groups[subgroup]
			if not sg_def.ancestors then
				sg_def.ancestors = {}
			end
			if not sg_def.users then
				sg_def.users = {}
			end
			if not arr_contains(sg_def.ancestors, group_source.name) then
				table.insert(sg_def.ancestors, target_name)
			end
			if sg_def and sg_def.permissions then
				setGroupPermissionsFrom(target_name, sg_def)
			end
		end
	end
end

-- Configure Factorio groups for permissions.
local function configureGroups()
	for name, groupdef in pairs(global.perm_definition.groups) do
		createGroup(name)
		setGroupPermissionsFrom(name, groupdef)
	end
end

-- Get (return) the Factorio permission group with appropriate name.
-- This is just a wrapper function.
local function getFactorioPermGroup(groupName)
	local permgroup = game.permissions.get_group(groupName)
	if not permgroup then
		game.print({'permissions.req_perms_nonexistent', groupName})
		return
	end
	return permgroup
end

-- Get the full list of permissions available to this group, including
-- inherited & custom permissions.
local function getGroupPerms(groupName)
	local permgroup = global.perm_definition.groups[groupName]
	if not permgroup then
		game.print({'permissions.req_perms_nonexistent', groupName})
		return
	end
	local permissions = table.deepcopy(permgroup.permissions)
	if permgroup and permgroup.inherit_perms_from and #permgroup.inherit_perms_from > 0 then
		for _, subgroup in pairs(permgroup.inherit_perms_from) do
			local sg_perms = getGroupPerms(subgroup)
			if sg_perms then
				for _, perm in pairs(sg_perms) do
					table.insert(permissions, perm)
				end
			end
		end
	end
	return permissions
end

-- Do a quick validation of data.
-- #TODO: this is very very incomplete.
local function checkSettings()
	if global.perm_definition.default_group == nil then
		error({'permissions.no_default'})
	end
	if getGroupPerms(global.perm_definition.default_group) == nil then
		error({'permissions.no_default_perms'})
	end
end

-- Do a quick post-creation validation of data
function perms.checkGroups(player)
	local printtarget = game
	if player then
		printtarget = player
	end
	for groupname, groupdef in pairs(global.perm_definition.groups) do
		if groupdef.should_have_all_perms then
			local fgroup = game.permissions.get_group(groupname)
			if fgroup == nil or fgroup.valid == false then
				printtarget.print("CHECK: Unable to find permissions group ".. groupname)
			else
				for act_name, act_id in pairs(defines.input_action) do
					if not perms.groupHasPermission(groupname, act_name) then
						printtarget.print("CHECK: Group "..groupname.." does not have permission: "..act_name)
					end
					if not fgroup.allows_action(act_id) then
						printtarget.print("CHECK: Group "..groupname.." does not have factorio permission: "..act_name)
					end
				end
				for _,permname in pairs(global.perm_definition.customPerms) do
					if not perms.groupHasPermission(groupname, permname) then
						printtarget.print("CHECK: Group "..groupname.." does not have permission: "..permname)
					end
				end
			end
		end
	end
end

-- Assign a user to a group.
function perms.setUserGroup(userName, groupName, noStoreUpdate)
	local user = global.user_definition[userName]
	-- Can't skip this, as it fails to generate the group structure correctly
	-- for other functionality.
	--if user and user.group == groupName then
	--	-- no work to do, already in the group!
	--	return
	--end
	if not user then
		--game.print({'permissions.debug_user_create', userName})
		global.user_definition[userName] = {}
		user = global.user_definition[userName]
		user.group = groupName
	end
	local permgroup = global.perm_definition.groups[groupName]
	if not permgroup then
		game.print({'permissions.user_to_unknown_group', userName, groupName})
		return
	end
	local fpermgroup = getFactorioPermGroup(groupName)
	if not fpermgroup then
		return
	end
	user.group = groupName

	-- remove from old group
	if user.lastGroup and global.perm_definition.groups[user.lastGroup] then
		--game.print(userName.." was in group '"..user.lastGroup.."': "..serpent.block(global.perm_definition.groups[user.lastGroup]))
		if global.perm_definition.groups[user.lastGroup].users then
			local userlist = global.perm_definition.groups[user.lastGroup].users
			for idx=#userlist, 1, -1 do
				local pname = userlist[idx]
				if pname == userName then
					table.remove(userlist, idx)
					break
				end
			end
		end
	end
	user.lastGroup = user.group
	-- add to new group
	if not permgroup.users then
		permgroup.users = {}
	end
	table.insert(permgroup.users, userName)

	-- add to factorio group
	local targetplayer = getPlayerNamed(userName)
	fpermgroup.add_player(targetplayer)
	perms.executeOnGroupUsers('moderator', true, false, {}, function(playerName)
		local player = getPlayerNamed(playerName)
		player.print({'permissions.user_assignment', userName, (permgroup.i18n_name or groupName)})
	end)
	Event.dispatch({name = Event.def("perms.user_group_change"), tick = game.tick, player_index = targetplayer.index})
    -- update keystore if available
    if remote.interfaces['keystore'] and not noStoreUpdate then
        remote.call('keystore', 'set', 'perm.player', userName, global.user_definition[userName], nil, true)
    end
end

function perms.revertGroup(playerName)
	local plperms = global.user_definition[playerName]
	perms.setUserGroup(playerName, plperms.lastGroup)
end

-- Assign user to their config-specified group.  If not specified,
-- then use the default group.
local function assignUserToDefault(userName)
	local user = global.user_definition[userName]
	if user and user.group and global.perm_definition.groups[user.group] then
		perms.setUserGroup(userName, user.group, true)
		--game.print({'permissions.debug_user_assign', userName,
		--	(global.perm_definition.groups[user.group].localized_name or user.group)})
	else
		perms.setUserGroup(userName, global.perm_definition.default_group, true)
		--game.print({'permissions.debug_user_assign', userName,
		--	(global.perm_definition.groups[global.perm_definition.default_group].localized_name or global.perm_definition.default_group)})
	end
end

-- Check if the group has the specified permission.
-- Primarily used for custom permissions.
function perms.groupHasPermission(groupName, permission, recurse)
	if recurse == nil then
		recurse = true
	end
	local permgroup = global.perm_definition.groups[groupName]
	if not permgroup then
		game.print({'permissions.req_perms_nonexistent', groupName})
		return false
	end
	for _, perm in pairs(permgroup.permissions) do
		if perm == permission then
			return true
		end
	end
	if permgroup and recurse and permgroup.inherit_perms_from and #permgroup.inherit_perms_from > 0 then
		for _, subgroup in pairs(permgroup.inherit_perms_from) do
			if perms.groupHasPermission(subgroup, permission) then
				return true
			end
		end
	end
	return false
end

-- Check if the user has the specified permission.
-- Primarily used for custom permissions.
-- Largely a wrapper function for groupHasPermission(..)
function perms.userHasPermission(userName, permission)
	local user = global.user_definition[userName]
	if not user then
		game.print({'permissions.req_user_perms_nonexistent', userName})
	else
		return perms.groupHasPermission(user.group, permission)
	end
	return false
end

function perms.addPermission(groupName, permName)
	local group = global.perm_definition.groups[groupName]
	if not group then
		game.print({"permissions.set_perms_nonexistent", groupName})
		return
	end
	if perms.groupHasPermission(groupName, permName) then
		game.print("DEBUG: Found permission we're trying to add.")
		-- permission already exists.
		return
	end
	-- add perm to group info
	table.insert(group.permissions, permName)

	local fperm = defines.input_action[permName]
	if fperm then
		-- add to factorio permission group(s).
		local grouplist = table.deepcopy(group.ancestors)
		table.insert(grouplist, groupName)
		for _, permgroup in pairs(grouplist) do
			--game.print("DEBUG: Setting '"..permName.."' to true for '"..permgroup.."'")
			local fpermgroup = game.permissions.get_group(permgroup)
			if not fpermgroup then
				game.print({"permissions.set_perms_nonexistent", permgroup})
			else
				fpermgroup.set_allows_action(fperm, true)
			end
		end
	end
	Event.dispatch({name=Event.def('perms.group_perm_add'), groupName=groupName, permName=permName})
end

function perms.removePermission(groupName, permName)
	local group = global.perm_definition.groups[groupName]
	if not group then
		game.print({"permissions.set_perms_nonexistent", groupName})
		return
	end
	if not perms.groupHasPermission(groupName, permName, false) then
		-- permission already missing.
		if perms.groupHasPermission(groupName, permName) then
			game.print({"permissions.perm_inherited", groupName, permName})
		else
			game.print({"permissions.perm_not_found", groupName, permName})
		end
		return
	end
	-- remove perm from group info
	for idx = #group.permissions, 1, -1 do
		if group.permissions[idx] == permName then
			--game.print("DEBUG: Found and removed permission.")
			table.remove(group.permissions, idx)
		end
	end
	-- remove from factorio permission group(s).
	local fperm = defines.input_action[permName]
	if fperm then
		local grouplist = table.deepcopy(group.ancestors)
		table.insert(grouplist, groupName)
		for _, permgroup in pairs(grouplist) do
			--game.print("DEBUG: Setting '"..permName.."' to false for '"..permgroup.."'")
			local fpermgroup = game.permissions.get_group(permgroup)
			if not fpermgroup then
				game.print({"permissions.set_perms_nonexistent", permgroup})
			elseif perms.groupHasPermission(permgroup, permName) then
				--game.print("DEBUG: Group '"..permgroup.."' has permission from another source.")
			else
				fpermgroup.set_allows_action(fperm, false)
			end
		end
	end
	Event.dispatch({name=Event.def('perms.group_perm_remove'), groupName=groupName, permName=permName})
end

function perms.registerPermission(permName)
	if not global.perm_definition.customPerms[permName] then
		table.insert(global.perm_definition.customPerms, permName)
	end
end

function perms.defaultPromoteGroupName()
	if not global.perm_definition.default_promote_group then
		return 'regular'
	end
	return global.perm_definition.default_promote_group
end
-- return a list of the groups that this player would know exist
-- Eg: down the heirarchy, not up.
local function getSubgroups(group)
	local glist = {}
	if group.inherit_perms_from then
		for _, inheritGroup in pairs(group.inherit_perms_from) do
			local subGroup = global.perm_definition.groups[inheritGroup]
			table.insert(glist, subGroup)
			for _,sub in pairs(getSubgroups(subGroup)) do
				table.insert(glist, sub)
			end
		end
	end
	return glist
end
function perms.knownGroups(playerName)
	local groupName = global.user_definition[playerName].group
	local groupList = getSubgroups(global.perm_definition.groups[groupName])
	table.insert(groupList, 1, global.perm_definition.groups[groupName])
	return groupList
end

-- returns the perm_group
function perms.group(groupName)
	return global.perm_definition.groups[groupName]
end

-- returns the player's group
function perms.playerGroup(playerName)
	if global.user_definition[playerName] then
		return perms.group(global.user_definition[playerName].group)
	end
	return ''
end

-- execute a function across members of a group
--global.counter=1
function perms.executeOnGroupUsers(groupName, with_ancestors, with_inherited, params, callback)
	local group = global.perm_definition.groups[groupName]
	--game.print("DEBUG: "..global.counter.." Executing on "..group.name)
	--global.counter = global.counter + 1

	for _, playerName in pairs(group.users) do
		callback(playerName, params)
	end

	if with_ancestors then
		for _, ancestorGroup in pairs(group.ancestors) do
			perms.executeOnGroupUsers(ancestorGroup, true, false, params, callback)
		end
	end
	if with_inherited then
		for _, inheritGroup in pairs(group.inherit_perms_from) do
			perms.executeOnGroupUsers(inheritGroup, false, true, params, callback)
		end
	end
end

-- get all players who are in a group or in a group inheriting from that.
function perms.playersWithGroup(in_group)
	local group = in_group
	if type(in_group) == 'string' then
		group = global.perm_definition.groups[in_group]
	end

	--game.print("DEBUG: Users in '"..group.name.."': ".. serpent.block(group.users))
	local users = table.deepcopy(group.users)
	for _, ancestorName in pairs(group.ancestors) do
		for jdx, userName in pairs(perms.playersWithGroup(ancestorName)) do
			--game.print("DEBUG: During "..ancestorName.." - Add '"..userName.."' to: "..serpent.block(users))
			table.insert(users, userName)
		end
	end
	return users
end

-- write out permissions file
function perms.writePermissions(player)
	local filemsg =
[=[--[[
	permission_definition.lua

	Distributed as Public Domain, with no license.
	This file was generated by a script.

	See Factorio's Lua API for a list of actions:
	http://lua-api.factorio.com/latest/defines.html#defines.input_action
	NOTE: The list may not be accurate.  During 0.15.x, the list had
	entries which had already been removed from the game, including
	defines.input_action.nothing & .stop-walking.
--]]

]=]
	outdef = table.deepcopy(global.perm_definition)
	for name, group in pairs(outdef.groups) do
		group.ancestors = nil
		group.users = nil
	end
	-- if player == 0, then we're writing only to server.
	if player and type(player) == uint then
		game.write_file('permission_definition.lua', filemsg.."return "..serpent.block(outdef), false, player)
	else
		game.write_file('permission_definition.lua', filemsg.."return "..serpent.block(outdef), false)
	end
end

function perms.writeUserAssignments(player)
	local filemsg =
[=[--[[
	permission_users.lua

	Distributed as Public Domain, with no license.
	This file was generated by a script.
--]]

]=]
	-- if player == 0, then we're writing only to server.
	if player and type(player) == uint then
		game.write_file('permission_users.lua', filemsg.."return "..serpent.block(global.user_definition), false, player)
	else
		game.write_file('permission_users.lua', filemsg.."return "..serpent.block(global.user_definition), false)
	end
end

-- writes the input-actions out to the scripts-output file.  This may be
-- useful for learning what input_actions actually still exist.
function perms.writeFactorioActionList(player)
	-- player == 0 writes only to the server.
	if player and type(player) == uint then
		game.write_file('factorio_input_actions.lua', "return "..serpent.block(global.user_definition), false, player)
	else
		game.write_file('factorio_input_actions.lua', "return "..serpent.block(global.user_definition), false)
	end
end


--
-- REMOTE INTERFACE
remote.add_interface("perms", {
	userHasPermission = perms.userHasPermission,
	groupHasPermission = perms.groupHasPermission,
	getGroupPerms = getGroupPerms,
	writePermissions = perms.writePermissions,
	writeUserAssignments = perms.writeUserAssignments,
	writeFactorioActionList = perms.writeFactorioActionList,

	addPermission = perms.addPermission,
	removePermission = perms.removePermission,
	registerPermission = perms.registerPermission,
	
	executeOnGroupUsers = perms.executeOnGroupUsers,
})


--
-- EVENTS

-- Initialization (useful if added to an existing map).
Event.register(Event.def("softmod_init"), function(event)
	mod_init()
	checkSettings()
	configureGroups()
	perms.checkGroups()

	--[[
	-- test inquiry:
	perms = getGroupPerms('Regular')
	for name, idx in pairs(defines.input_action) do
		game.print(name .. " = " .. serpent.block(perms.allows_action(idx)))
		log(name .. " = " .. serpent.block(perms.allows_action(idx)))
	end
	--]]
	--[[
	game.print("Moderator has: "..serpent.block(getGroupPerms('Moderator')))
	local fpermgroup = getFactorioPermGroup('Moderator')
	local fperms = {}
	for ac_name, ac_id in pairs(defines.input_action) do
		if fpermgroup.allows_action(ac_id) then
			table.insert(fperms, ac_name)
		end
	end
	game.print("Moderator has factorio perms: "..serpent.block(fperms))
	--]]
end)

function loadPersistentPlayer(data)
	--print("loadPersistenPlayer(): " .. serpent.block(data))
	if data.status and data.status == "success" then
		local playerName = data.field
		local group = data.value.group
		--game.print({'permissions.load_persistent', playerName, group})
		perms.setUserGroup(playerName, group, true)
	elseif data.error then
		print("Error getting persistent player data: " .. serpent.line(data.error))
		-- if the player has settings from the permission_users.lua file, then
		-- create them a new entry in the permissions system:
		if data.error == "key not found" and data.field and 
		   global.user_definition[data.field] and 
		   global.user_definition[data.field].group ~= global.perm_definition.default_group then
			remote.call('keystore', 'set', 'perm.player', data.field, global.user_definition[data.field], nil, true)
		end
	end
end

-- Assign player to group upon join.
Event.register(defines.events.on_player_joined_game, function(event)
	mod_init()
	local player = game.players[event.player_index]
	assignUserToDefault(player.name)
	if remote.interfaces['keystore'] then
		remote.call('keystore', 'get', 'perm.player', player.name, loadPersistentPlayer, true)
	end
end)

Event.register(defines.events.on_tick, function(event)
	if event.tick % 3600 == 1 then -- once/minute
		for idx, player in pairs(game.connected_players) do
			local group = perms.playerGroup(player.name)
			if group and group.autopromote then
				-- this assumes 60 ups.
				if player.online_time > group.autopromote.time * 60 then
					perms.setUserGroup(player.name, group.autopromote.to)
					local newgroup = perms.group(group.autopromote.to)
					player.print({'permissions.you_autopromoted', newgroup.i18n_name})
				end
			end
		end
	end
end)
